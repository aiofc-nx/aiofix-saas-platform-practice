---
description: 系统架构与代码组织架构
globs:
alwaysApply: true
---

# 系统架构与代码组织架构原则

本项目的目标是开发一个企业级的 SAAS 平台，遵循整洁架构（Clean Architecture）和领域驱动设计（DDD）的思想和原则。
项目采用混合架构，技术栈包括：Clean Architecture + RESTful API + CQRS + GraphQL + 事件溯源 + 多数据库支持

## 🏗️ 整体架构模式

### SaaS 平台架构特征

```
HL8 SaaS 平台
├── 多租户（下设组织及部门）架构 (Multi-Tenant)
│   ├── 多层级数据隔离策略
│   │   ├── 平台级隔离 (Platform Level)
│   │   ├── 租户级隔离 (Tenant Level)
│   │   ├── 组织级隔离 (Organization Level)
│   │   ├── 部门级隔离 (Department Level)
│   │   ├── 子部门级隔离 (Sub-Department Level)
│   │   └── 用户级隔离 (User Level - 跨层级存在)
│   ├── 数据隐私级别控制
│   │   ├── 可共享数据 (Shared Data)
│   │   └── 受保护数据 (Protected Data)
│   ├── 数据访问控制机制
│   │   ├── 基于隔离级别的访问控制
│   │   ├── 基于隐私级别的访问控制
│   │   └── 跨层级访问控制
│   ├── 资源配额管理
│   └── 计费与订阅管理
├── 单体应用架构优先+兼容微服务架构 (Microservices)
│   ├── 服务拆分策略（模块化独立依赖包）
│   ├── 单体应用服务集成策略
├── CQRS + 事件溯源架构 (CQRS + Event Sourcing)
│   ├── 命令查询职责分离 (CQRS)
│   ├── 事件溯源 (Event Sourcing)
│   ├── 读模型投影 (Read Model Projections)
│   └── 状态重建能力
└── 云原生架构 (Cloud-Native)
    ├── 容器化部署
    ├── 弹性伸缩
    └── 可观测性
```

### Clean Architecture 分层设计

```
Clean Architecture 四层架构
┌─────────────────────────────────────┐
│     Presentation Layer (表现层)      │  ← REST API、GraphQL、WebSocket
├─────────────────────────────────────┤
│     Application Layer (应用层)       │  ← Use Cases、Commands、Queries、Handlers、Data Access Control
├─────────────────────────────────────┤
│       Domain Layer (领域层)         │  ← Entities、Value Objects、Aggregates、Domain Events、Data Isolation Aware
├─────────────────────────────────────┤
│    Infrastructure Layer (基础设施层)  │  ← 数据库、缓存、事件存储、外部服务
└─────────────────────────────────────┘
```

**各层之间依赖方向只能指向内层，外层不得依赖内层实现细节，确保系统的可维护性和可扩展性。**

**各领域模块需要共享的组件我们统一抽离出来，以独立模块的形式开发，作为 shared 领域模块，各领域模块不再创建共享领域层。**

## 🎯 核心架构模式

### RESTful + CQRS + GraphQL + 事件溯源

我们的系统采用四种核心架构模式的组合：

#### 1. **RESTful API** - 命令接口

- **职责**: 处理写操作和简单查询
- **特点**: 简单直接、标准化、易于理解
- **适用场景**: 用户创建、更新、删除、认证操作

#### 2. **CQRS** - 读写分离

- **职责**: 命令端处理写操作，查询端处理读操作
- **特点**: 性能优化、可扩展性、职责清晰
- **适用场景**: 高并发读写场景、复杂查询优化

#### 3. **GraphQL** - 灵活查询

- **职责**: 处理复杂查询和关联数据
- **特点**: 灵活查询、减少网络请求、类型安全
- **适用场景**: 复杂数据查询、前端数据获取优化

#### 4. **事件溯源** - 状态管理

- **职责**: 状态变更记录、审计追踪、状态重建
- **特点**: 完整历史记录、可追溯性、状态一致性
- **适用场景**: 业务审计、状态重建、数据一致性

### 架构协作关系

```
前端应用
    ↓
┌─────────────────────────────────────┐
│           Presentation Layer        │
│  ┌─────────────┐  ┌─────────────┐  │
│  │ RESTful API │  │   GraphQL   │  │
│  └─────────────┘  └─────────────┘  │
└─────────────────────────────────────┘
    ↓                    ↓
┌─────────────────────────────────────┐
│         Application Layer           │
│  ┌─────────────┐  ┌─────────────┐  │
│  │  Use Cases  │  │ Commands    │  │
│  │             │  │ Queries     │  │
│  └─────────────┘  └─────────────┘  │
│  ┌─────────────┐  ┌─────────────┐  │
│  │  Handlers   │  │ Projections │  │
│  └─────────────┘  └─────────────┘  │
│  ┌─────────────┐  ┌─────────────┐  │
│  │Data Access  │  │ Validators  │  │
│  │  Control    │  │             │  │
│  └─────────────┘  └─────────────┘  │
└─────────────────────────────────────┘
    ↓                    ↓
┌─────────────────────────────────────┐
│           Domain Layer              │
│  ┌─────────────┐  ┌─────────────┐  │
│  │ Aggregates  │  │  Entities   │  │
│  │ Domain Evt  │  │ Value Objs  │  │
│  └─────────────┘  └─────────────┘  │
│  ┌─────────────┐  ┌─────────────┐  │
│  │Data Isolation│ │ Domain Svc  │  │
│  │   Aware     │  │             │  │
│  └─────────────┘  └─────────────┘  │
└─────────────────────────────────────┘
    ↓                    ↓
┌─────────────────────────────────────┐
│        Infrastructure Layer         │
│  ┌─────────────┐  ┌─────────────┐  │
│  │ PostgreSQL  │  │  MongoDB    │  │
│  │ (Commands)  │  │ (Queries)   │  │
│  │ Event Store │  │ Read Models │  │
│  └─────────────┘  └─────────────┘  │
└─────────────────────────────────────┘
```

### 数据流示例

#### 平台用户创建流程

1. **前端** → RESTful API (`POST /api/platform/users`)
2. **Use Case** → `CreatePlatformUserUseCase.execute()`
3. **数据访问控制** → `DataAccessControlService.checkAccess()`
4. **命令** → `CreatePlatformUserCommand`
5. **命令处理器** → `CreatePlatformUserHandler.execute()`
6. **聚合根** → `PlatformUserAggregate.create()`
7. **领域实体** → `PlatformUserEntity` (平台级实体)
8. **领域事件** → `PlatformUserCreatedEvent` (包含平台级数据隔离信息)
9. **事件存储** → 保存事件到 PostgreSQL
10. **投影** → 更新读模型到 MongoDB

#### 租户用户创建流程

1. **前端** → RESTful API (`POST /api/tenants/{tenantId}/users`)
2. **Use Case** → `CreateTenantUserUseCase.execute()`
3. **数据访问控制** → `DataAccessControlService.checkAccess()`
4. **命令** → `CreateTenantUserCommand`
5. **命令处理器** → `CreateTenantUserHandler.execute()`
6. **聚合根** → `TenantUserAggregate.create()`
7. **领域实体** → `TenantUserEntity` (数据隔离感知实体)
8. **领域事件** → `TenantUserCreatedEvent` (包含数据隔离信息)
9. **事件存储** → 保存事件到 PostgreSQL
10. **投影** → 更新读模型到 MongoDB

#### 平台用户查询流程

1. **前端** → GraphQL Query (`platformUser(id: "123")`)
2. **Use Case** → `GetPlatformUserUseCase.execute()`
3. **数据访问控制** → `DataAccessControlService.checkAccess()`
4. **查询** → `GetPlatformUserByIdQuery`
5. **查询处理器** → `GetPlatformUserByIdHandler.execute()`
6. **读模型** → 从 MongoDB 获取数据（包含平台级数据隔离信息）
7. **数据隔离验证** → 验证平台用户访问权限
8. **GraphQL Resolver** → 组装关联数据
9. **前端** → 获取完整的平台用户信息

#### 租户用户查询流程

1. **前端** → GraphQL Query (`tenantUser(id: "123")`)
2. **Use Case** → `GetTenantUserUseCase.execute()`
3. **数据访问控制** → `DataAccessControlService.checkAccess()`
4. **查询** → `GetTenantUserByIdQuery`
5. **查询处理器** → `GetTenantUserByIdHandler.execute()`
6. **读模型** → 从 MongoDB 获取数据（包含数据隔离信息）
7. **数据隔离验证** → 验证租户用户访问权限
8. **GraphQL Resolver** → 组装关联数据
9. **前端** → 获取完整的租户用户信息

## 🏗️ 架构设计原则

### Use Case 设计原则

```typescript
// Use Case 是业务逻辑的统一入口
@Injectable()
export class CreateUserUseCase {
  constructor(
    private readonly commandBus: CommandBus,
    private readonly userRepository: UserRepository,
    private readonly emailService: EmailService,
    private readonly auditService: AuditService
  ) {}

  async execute(request: CreateUserRequest): Promise<CreateUserResponse> {
    // 1. 业务规则验证
    await this.validateBusinessRules(request);

    // 2. 创建命令
    const command = new CreateUserCommand(
      request.username,
      request.email,
      request.password,
      request.tenantId
    );

    // 3. 执行命令
    await this.commandBus.execute(command);

    // 4. 业务逻辑处理
    await this.sendWelcomeEmail(request.email);
    await this.auditService.logUserCreation(request);

    return { userId: command.userId, success: true };
  }

  private async validateBusinessRules(
    request: CreateUserRequest
  ): Promise<void> {
    // 业务规则验证逻辑
  }
}
```

### 领域模型分层设计

```typescript
// 1. 聚合根 (Aggregate Root) - 业务规则和一致性边界
export class UserAggregate {
  private user: UserEntity;
  private uncommittedEvents: DomainEvent[] = [];

  static create(
    username: string,
    email: string,
    password: string,
    tenantId: Uuid,
    organizationId?: Uuid,
    departmentIds: Uuid[] = [],
    dataPrivacyLevel: DataPrivacyLevel = DataPrivacyLevel.PROTECTED
  ): UserAggregate {
    const aggregate = new UserAggregate();
    const userId = UserId.generate();

    // 创建用户实体（数据隔离感知）
    aggregate.user = UserEntity.create(
      userId,
      username,
      email,
      tenantId,
      organizationId,
      departmentIds,
      dataPrivacyLevel
    );

    // 应用业务规则
    aggregate.applyPasswordPolicy(password);

    // 产生领域事件（包含数据隔离信息）
    aggregate.apply(
      new UserCreatedEvent(
        userId,
        username,
        email,
        tenantId,
        organizationId,
        departmentIds,
        DataIsolationLevel.USER,
        dataPrivacyLevel
      )
    );

    return aggregate;
  }

  changeEmail(newEmail: EmailValueObject): void {
    // 业务规则验证
    if (this.user.email.equals(newEmail)) {
      return;
    }

    // 更新实体
    this.user.changeEmail(newEmail);

    // 产生领域事件
    this.apply(
      new UserEmailChangedEvent(this.user.id, this.user.email, newEmail)
    );
  }

  private applyPasswordPolicy(password: string): void {
    // 密码策略业务规则
  }
}

// 2. 实体 (Entity) - 业务实体，有标识，数据隔离感知
export class UserEntity extends DataIsolationAwareEntity {
  private username: UsernameValueObject;
  private email: EmailValueObject;
  private status: UserStatus;

  constructor(
    id: UserId,
    username: string,
    email: string,
    tenantId: Uuid,
    organizationId?: Uuid,
    departmentIds: Uuid[] = [],
    dataPrivacyLevel: DataPrivacyLevel = DataPrivacyLevel.PROTECTED
  ) {
    super(
      tenantId,
      DataIsolationLevel.USER,
      dataPrivacyLevel,
      id,
      organizationId,
      departmentIds,
      id // userId 与实体ID相同
    );
    this.username = new UsernameValueObject(username);
    this.email = new EmailValueObject(email);
    this.status = UserStatus.ACTIVE;
  }

  static create(
    id: UserId,
    username: string,
    email: string,
    tenantId: Uuid,
    organizationId?: Uuid,
    departmentIds: Uuid[] = [],
    dataPrivacyLevel: DataPrivacyLevel = DataPrivacyLevel.PROTECTED
  ): UserEntity {
    return new UserEntity(
      id,
      username,
      email,
      tenantId,
      organizationId,
      departmentIds,
      dataPrivacyLevel
    );
  }

  changeEmail(newEmail: EmailValueObject): void {
    this.email = newEmail;
  }

  // 数据访问控制方法
  canAccess(target: DataIsolationAwareEntity): boolean {
    return super.canAccess(target);
  }

  // Getters
  get id(): UserId {
    return this.id;
  }
  get username(): UsernameValueObject {
    return this.username;
  }
  get email(): EmailValueObject {
    return this.email;
  }
  get status(): UserStatus {
    return this.status;
  }
}

// 3. 值对象 (Value Object) - 不可变对象
export class EmailValueObject {
  constructor(private readonly value: string) {
    this.validate();
  }

  private validate(): void {
    if (!isValidEmail(this.value)) {
      throw new InvalidEmailException(this.value);
    }
  }

  equals(other: EmailValueObject): boolean {
    return this.value === other.value;
  }

  toString(): string {
    return this.value;
  }
}
```

### 依赖关系原则

```
依赖方向 (Dependency Direction)
┌─────────────────────────────────────┐
│     Presentation Layer              │
│  ┌─────────────┐  ┌─────────────┐  │
│  │ Controllers │  │  Resolvers  │  │
│  └─────────────┘  └─────────────┘  │
│           ↓                         │
└─────────────────────────────────────┘
┌─────────────────────────────────────┐
│      Application Layer              │
│  ┌─────────────┐  ┌─────────────┐  │
│  │  Use Cases  │  │  Handlers   │  │
│  └─────────────┘  └─────────────┘  │
│  ┌─────────────┐  ┌─────────────┐  │
│  │Data Access  │  │ Validators  │  │
│  │  Control    │  │             │  │
│  └─────────────┘  └─────────────┘  │
│           ↓                         │
└─────────────────────────────────────┘
┌─────────────────────────────────────┐
│        Domain Layer                 │
│  ┌─────────────┐  ┌─────────────┐  │
│  │ Aggregates  │  │  Entities   │  │
│  └─────────────┘  └─────────────┘  │
│  ┌─────────────┐  ┌─────────────┐  │
│  │Data Isolation│ │ Value Objs  │  │
│  │   Aware     │  │             │  │
│  └─────────────┘  └─────────────┘  │
│           ↓                         │
└─────────────────────────────────────┘
┌─────────────────────────────────────┐
│     Infrastructure Layer            │
│  ┌─────────────┐  ┌─────────────┐  │
│  │ Repositories│  │   Services  │  │
│  └─────────────┘  └─────────────┘  │
└─────────────────────────────────────┘
```

**关键原则**：

- 外层只能依赖内层
- 内层不能依赖外层
- Use Case 是业务逻辑的统一入口
- 聚合根管理业务规则和一致性
- 实体和值对象分离，职责清晰
- 数据隔离感知实体负责数据访问控制
- 应用层数据访问控制服务负责权限验证

### 高性能策略

```
性能优化策略
├── 缓存策略
│   ├── Redis多级缓存
│   ├── 查询结果缓存
│   ├── 权限缓存
│   ├── 数据隔离缓存
│   └── 会话缓存
├── 数据库优化
│   ├── 读写分离
│   ├── 分库分表
│   ├── 索引优化
│   ├── 数据隔离索引
│   └── 查询优化
├── 异步处理
│   ├── 事件投影
│   ├── 读模型更新
│   ├── 后台任务
│   └── 批量处理
├── 数据隔离优化
│   ├── 租户级缓存隔离
│   ├── 组织级查询优化
│   ├── 部门级数据分区
│   └── 用户级访问控制缓存
└── CDN与压缩
    ├── 静态资源CDN
    ├── API响应压缩
    ├── 图片压缩
    └── 文件压缩
```

## 🔄 开发流程与架构

### CQRS 目录结构最佳实践

#### 应用层目录组织原则

```
application/
├── use-cases/          # 用例 (业务逻辑入口)
├── commands/           # 命令 (写操作)
│   ├── handlers/      # 命令处理器
│   └── validators/    # 命令验证器
├── queries/           # 查询 (读操作)
│   ├── handlers/      # 查询处理器
│   └── validators/    # 查询验证器
├── projections/       # 读模型投影
├── services/          # 应用服务
└── interfaces/        # 应用层接口
```

**设计原则**：
- **命令和查询分离**：写操作和读操作完全分离
- **处理器就近原则**：handlers放在对应的commands/queries目录下
- **验证器分离**：每个命令/查询都有对应的验证器
- **职责清晰**：每个目录都有明确的职责边界

### Clean Architecture + CQRS + 事件溯源 + GraphQL + 数据隔离 模式

```typescript
// 业务逻辑通过 Use Case 统一调用 CQRS，集成数据隔离控制
Presentation Layer          Application Layer
     ↓                           ↓
[REST API] → [Use Case] → [Data Access Control] → [Command/Query] → [Handler]
[GraphQL] → [Use Case] → [Data Access Control] → [Command/Query] → [Handler]
     ↓                           ↓
Domain Layer              Infrastructure Layer
[Aggregate] ←→ [Data Isolation Aware Entity] ←→ [Repository] ←→ [Database]
[Domain Event] ←→ [Event Store] ←→ [Projection]
```

### Clean Architecture 开发流程

```
Clean Architecture 开发流程
1. 业务需求 → 2. Use Case 定义 → 3. 数据访问控制 → 4. 命令/查询 → 5. 处理器
                        ↓
9. 前端响应 ← 8. 数据返回 ← 7. 读模型投影 ← 6. 事件存储
```

### 领域模型设计原则

```
领域模型分层
┌─────────────────────────────────────┐
│           Aggregate (聚合根)         │  ← 业务规则、一致性边界
│  ├── PlatformUserAggregate         │  ← 平台用户聚合根
│  ├── TenantUserAggregate           │  ← 租户用户聚合根
│  ├── TenantAggregate               │  ← 租户聚合根
│  └── OrganizationAggregate         │  ← 组织聚合根
├─────────────────────────────────────┤
│           Entity (实体)             │  ← 业务实体、标识
│  ┌─────────────────────────────────┐ │
│  │   PlatformEntity               │ │  ← 平台级实体基类
│  │   ├── PlatformUserEntity       │ │  ← 平台用户实体
│  │   ├── PlatformConfigEntity     │ │  ← 平台配置实体
│  │   └── SystemConfigEntity       │ │  ← 系统配置实体
│  │   DataIsolationAwareEntity     │ │  ← 数据隔离感知实体基类
│  │   ├── TenantUserEntity         │ │  ← 租户用户实体
│  │   ├── TenantEntity             │ │  ← 租户实体
│  │   ├── OrganizationEntity       │ │  ← 组织实体
│  │   └── DepartmentEntity         │ │  ← 部门实体
│  └─────────────────────────────────┘ │
├─────────────────────────────────────┤
│        Value Object (值对象)        │  ← 不可变对象、业务概念
│  ├── UserId, TenantId              │  ← 标识值对象
│  ├── Username, Email, Password     │  ← 业务值对象
│  └── TenantDomain, TenantName      │  ← 租户值对象
└─────────────────────────────────────┘
```

## 🛠️ 技术架构栈

### 后端技术栈

```typescript
// 核心框架与语言
- 语言: TypeScript 5.x
- 框架: NestJS 11.x
- 数据库: PostgreSQL 15.x (命令端 + 事件存储) + MongoDB 7.x (查询端)
- 缓存: Redis 7.x
- 事件存储: PostgreSQL Event Store

// API 接口
- RESTful API: 命令操作 (写操作)
- GraphQL: 查询操作 (读操作)
- WebSocket: 实时通信

// 认证与权限
- 认证: Passport.js + JWT
- 权限控制: CASL (基于能力的访问控制)
- 数据隔离: 多层级数据隔离策略
- 访问控制: 基于隔离级别和隐私级别的细粒度访问控制
- 多因子认证: TOTP、短信验证码

// 数据层
- ORM: MikroORM (支持PostgreSQL & MongoDB)
- 连接池: pg-pool, mongodb connection pool
- 数据迁移: MikroORM migrations
- 数据同步: 事件投影机制
- 数据隔离: 租户级、组织级、部门级、用户级隔离

// 架构模式
- CQRS: 命令查询职责分离
- 事件溯源: 状态管理和审计追踪
- GraphQL: 灵活查询和数据获取
- 数据隔离: 完整的多层级数据隔离策略
```

### 前端技术栈

(待定)

## **后端代码组织架构划分原则**

### 模块架构设计原则

遵循领域驱动设计（DDD）思想，代码目录架构应当首先体现领域的边界。新的架构将业务管理模块与认证授权模块分离，确保职责清晰。

#### 设计原则详解

**核心原则**：
- **业务领域优先**：首先按业务领域（platform、tenant、user、organization、department）划分
- **认证授权分离**：IAM 模块专注于认证授权，不管理业务实体
- **分层架构其次**：在每个模块内部再按分层架构组织
- **功能组件最后**：在每层内部按功能组件组织

**命名规范**：
- **管理模块**：以业务领域名称命名（如：platform、tenant、user、organization、department）
- **服务模块**：以服务类型命名（如：iam、shared）
- **分层目录**：以架构层名称命名（如：domain、application、infrastructure、presentation）
- **功能组件**：以功能组件名称命名（如：entities、use-cases、controllers、repositories）

**优势**：
1. **业务内聚性**：相关功能聚集在同一个管理模块
2. **职责边界清晰**：管理模块负责业务逻辑，IAM 模块负责认证授权
3. **可维护性**：修改某个领域时影响范围可控
4. **可扩展性**：新增领域时结构清晰
5. **团队协作**：不同团队可以专注不同领域

#### 新的模块架构示例

```
# 新的模块架构 - 业务管理模块与认证授权模块分离

libs/core/                    # 核心业务模块
├── platform/                 # 平台管理模块
│   ├── src/
│   │   ├── domain/          # 领域层
│   │   │   ├── entities/    # 平台配置实体、系统设置实体
│   │   │   ├── value-objects/# 平台相关值对象
│   │   │   ├── aggregates/  # 平台配置聚合根
│   │   │   ├── domain-events/# 平台配置事件
│   │   │   └── repositories/# 平台仓储接口
│   │   ├── application/     # 应用层
│   │   ├── infrastructure/  # 基础设施层
│   │   └── presentation/    # 表现层
│   ├── package.json
│   └── tsconfig.json
├── tenant/                   # 租户管理模块
│   ├── src/
│   │   ├── domain/          # 领域层
│   │   │   ├── entities/    # 租户实体、租户配置实体
│   │   │   ├── value-objects/# 租户相关值对象
│   │   │   ├── aggregates/  # 租户聚合根
│   │   │   └── repositories/# 租户仓储接口
│   │   ├── application/     # 应用层
│   │   ├── infrastructure/  # 基础设施层
│   │   └── presentation/    # 表现层
│   ├── package.json
│   └── tsconfig.json
├── user/                     # 用户管理模块（统一管理平台用户+租户用户）
│   ├── src/
│   │   ├── domain/          # 领域层
│   │   │   ├── entities/    # 用户实体、用户档案实体
│   │   │   ├── value-objects/# 用户相关值对象
│   │   │   ├── aggregates/  # 用户聚合根
│   │   │   └── repositories/# 用户仓储接口
│   │   ├── application/     # 应用层
│   │   ├── infrastructure/  # 基础设施层
│   │   └── presentation/    # 表现层
│   ├── package.json
│   └── tsconfig.json
├── organization/             # 组织管理模块
│   ├── src/
│   │   ├── domain/          # 领域层
│   │   ├── application/     # 应用层
│   │   ├── infrastructure/  # 基础设施层
│   │   └── presentation/    # 表现层
│   ├── package.json
│   └── tsconfig.json
├── department/               # 部门管理模块
│   ├── src/
│   │   ├── domain/          # 领域层
│   │   ├── application/     # 应用层
│   │   ├── infrastructure/  # 基础设施层
│   │   └── presentation/    # 表现层
│   ├── package.json
│   └── tsconfig.json
└── iam/                      # 身份认证与授权管理模块
    ├── src/
    │   ├── auth/            # 认证子领域
    │   │   ├── domain/      # 领域层
    │   │   ├── application/ # 应用层
    │   │   ├── infrastructure/# 基础设施层
    │   │   └── presentation/# 表现层
    │   ├── role/            # 角色子领域
    │   │   ├── domain/      # 领域层
    │   │   ├── application/ # 应用层
    │   │   ├── infrastructure/# 基础设施层
    │   │   └── presentation/# 表现层
    │   ├── permission/      # 权限子领域
    │   │   ├── domain/      # 领域层
    │   │   ├── application/ # 应用层
    │   │   ├── infrastructure/# 基础设施层
    │   │   └── presentation/# 表现层
    │   ├── session/         # 会话子领域
    │   │   ├── domain/      # 领域层
    │   │   ├── application/ # 应用层
    │   │   ├── infrastructure/# 基础设施层
    │   │   └── presentation/# 表现层
    │   └── audit/           # 审计子领域
    │       ├── domain/      # 领域层
    │       ├── application/ # 应用层
    │       ├── infrastructure/# 基础设施层
    │       └── presentation/# 表现层
    ├── package.json
    └── tsconfig.json

libs/shared/                  # 共享基础设施模块
├── src/
│   ├── domain/              # 共享领域组件
│   │   ├── entities/        # 基础实体类
│   │   ├── value-objects/   # 通用值对象
│   │   └── enums/           # 通用枚举
│   ├── infrastructure/      # 共享基础设施
│   └── presentation/        # 共享表现层组件
├── package.json
└── tsconfig.json
```
```

#### 应用示例

**正确示例**：
- ✅ `libs/core/iam/src/auth/infrastructure/jwt.service.ts` - IAM认证子领域的基础设施服务
- ✅ `libs/core/platform/src/domain/entities/platform-config.entity.ts` - 平台管理模块的领域实体
- ✅ `libs/core/tenant/src/domain/entities/tenant.entity.ts` - 租户管理模块的领域实体
- ✅ `libs/core/user/src/domain/entities/user.entity.ts` - 用户管理模块的领域实体
- ✅ `libs/core/iam/src/role/application/use-cases/create-role.usecase.ts` - IAM角色子领域的应用用例

**错误示例**：
- ❌ `libs/core/iam/src/infrastructure/auth/jwt.service.ts` - 按分层架构组织，不符合DDD原则
- ❌ `libs/core/iam/src/domain/user/user.entity.ts` - 用户实体不应放在IAM模块中
- ❌ `libs/core/iam/src/platform/domain/entities/platform-user.entity.ts` - 平台用户实体不应放在IAM模块中

### 完整目录结构示例

遵循领域驱动设计（DDD）思想，代码目录架构应当首先体现领域的边界。新的架构将业务管理模块与认证授权模块分离，确保职责清晰。示例目录结构如下：

```
apps/api # api应用

libs/core/                    # 核心业务模块
├── platform/                 # 平台管理模块
│   ├── src/
│   │   ├── domain/          # 领域层
│   │   │   ├── entities/    # 实体 (业务实体)
│   │   │   │   ├── platform-config.entity.ts # 平台配置实体
│   │   │   │   ├── platform-system-setting.entity.ts # 系统设置实体
│   │   │   │   └── platform-public-data.entity.ts # 公共数据实体
│   │   │   ├── value-objects/ # 值对象 (不可变对象)
│   │   │   │   ├── platform-config-key.vo.ts # 平台配置键值对象
│   │   │   │   └── platform-config-value.vo.ts # 平台配置值值对象
│   │   │   ├── aggregates/  # 聚合根 (业务规则、一致性边界)
│   │   │   │   └── platform-config.aggregate.ts # 平台配置聚合根
│   │   │   ├── domain-events/ # 领域事件
│   │   │   │   └── platform-config-updated.event.ts
│   │   │   ├── domain-services/ # 领域服务
│   │   │   ├── repositories/ # 仓储接口
│   │   │   ├── exceptions/   # 领域异常
│   │   │   ├── enums/        # 枚举
│   │   │   └── types/        # 类型定义
│   │   ├── application/      # 应用层
│   │   │   ├── use-cases/    # 用例 (业务逻辑入口)
│   │   │   │   └── update-platform-config.usecase.ts # 更新平台配置用例
│   │   │   ├── commands/     # 命令 (写操作)
│   │   │   │   ├── handlers/ # 命令处理器
│   │   │   │   └── validators/ # 命令验证器
│   │   │   ├── queries/      # 查询 (读操作)
│   │   │   │   ├── handlers/ # 查询处理器
│   │   │   │   └── validators/ # 查询验证器
│   │   │   ├── projections/  # 读模型投影
│   │   │   ├── services/     # 应用服务
│   │   │   └── interfaces/   # 应用层接口
│   │   ├── infrastructure/   # 基础设施层
│   │   │   ├── repositories/ # 仓储实现
│   │   │   ├── mappers/      # 映射器
│   │   │   ├── entities/     # ORM实体
│   │   │   ├── services/     # 基础设施服务
│   │   │   ├── external/     # 外部服务集成
│   │   │   ├── config/       # 配置
│   │   │   └── migrations/   # 数据库迁移
│   │   └── presentation/     # 表现层
│   │       ├── controllers/  # 控制器
│   │       ├── dtos/         # 数据传输对象
│   │       ├── validators/   # 表现层验证器
│   │       ├── guards/       # 权限守卫
│   │       └── interceptors/ # 拦截器
│   ├── package.json
│   └── tsconfig.json

├── tenant/                    # 租户管理模块
│   ├── src/
│   │   ├── domain/           # 领域层
│   │   │   ├── entities/     # 实体 (业务实体)
│   │   │   │   ├── tenant.entity.ts # 租户实体
│   │   │   │   └── tenant-config.entity.ts # 租户配置实体
│   │   │   ├── value-objects/ # 值对象 (不可变对象)
│   │   │   │   ├── tenant-id.vo.ts # 租户ID值对象
│   │   │   │   ├── tenant-domain.vo.ts # 租户域名值对象
│   │   │   │   └── tenant-name.vo.ts # 租户名称值对象
│   │   │   ├── aggregates/   # 聚合根 (业务规则、一致性边界)
│   │   │   │   ├── tenant.aggregate.ts # 租户聚合根
│   │   │   │   └── tenant-config.aggregate.ts # 租户配置聚合根
│   │   │   ├── domain-events/ # 领域事件
│   │   │   │   ├── tenant-created.event.ts
│   │   │   │   ├── tenant-activated.event.ts
│   │   │   │   └── tenant-config-updated.event.ts
│   │   │   ├── domain-services/ # 领域服务
│   │   │   ├── repositories/ # 仓储接口
│   │   │   ├── exceptions/   # 领域异常
│   │   │   ├── enums/        # 枚举
│   │   │   └── types/        # 类型定义
│   │   ├── application/      # 应用层
│   │   │   ├── use-cases/    # 用例 (业务逻辑入口)
│   │   │   │   ├── create-tenant.usecase.ts # 创建租户用例
│   │   │   │   ├── activate-tenant.usecase.ts # 激活租户用例
│   │   │   │   └── update-tenant-config.usecase.ts # 更新租户配置用例
│   │   │   ├── commands/     # 命令 (写操作)
│   │   │   │   ├── handlers/ # 命令处理器
│   │   │   │   └── validators/ # 命令验证器
│   │   │   ├── queries/      # 查询 (读操作)
│   │   │   │   ├── handlers/ # 查询处理器
│   │   │   │   └── validators/ # 查询验证器
│   │   │   ├── projections/  # 读模型投影
│   │   │   ├── services/     # 应用服务
│   │   │   └── interfaces/   # 应用层接口
│   │   ├── infrastructure/   # 基础设施层
│   │   │   ├── repositories/ # 仓储实现
│   │   │   ├── mappers/      # 映射器
│   │   │   ├── entities/     # ORM实体
│   │   │   ├── services/     # 基础设施服务
│   │   │   ├── external/     # 外部服务集成
│   │   │   ├── config/       # 配置
│   │   │   └── migrations/   # 数据库迁移
│   │   └── presentation/     # 表现层
│   │       ├── controllers/  # 控制器
│   │       ├── dtos/         # 数据传输对象
│   │       ├── validators/   # 表现层验证器
│   │       ├── guards/       # 权限守卫
│   │       └── interceptors/ # 拦截器
│   ├── package.json
│   └── tsconfig.json

├── user/                      # 用户管理模块（统一管理平台用户+租户用户）
│   ├── src/
│   │   ├── domain/           # 领域层
│   │   │   ├── entities/     # 实体 (业务实体)
│   │   │   │   ├── user.entity.ts # 用户实体
│   │   │   │   └── user-profile.entity.ts # 用户档案实体
│   │   │   ├── value-objects/ # 值对象 (不可变对象)
│   │   │   │   ├── user-id.vo.ts # 用户ID值对象
│   │   │   │   ├── username.vo.ts # 用户名字值对象
│   │   │   │   ├── email.vo.ts # 邮箱值对象
│   │   │   │   └── password.vo.ts # 密码值对象
│   │   │   ├── aggregates/   # 聚合根 (业务规则、一致性边界)
│   │   │   │   ├── user.aggregate.ts # 用户聚合根
│   │   │   │   └── user-profile.aggregate.ts # 用户档案聚合根
│   │   │   ├── domain-events/ # 领域事件
│   │   │   │   ├── user-created.event.ts
│   │   │   │   ├── user-activated.event.ts
│   │   │   │   └── user-profile-updated.event.ts
│   │   │   ├── domain-services/ # 领域服务
│   │   │   ├── repositories/ # 仓储接口
│   │   │   ├── exceptions/   # 领域异常
│   │   │   ├── enums/        # 枚举
│   │   │   └── types/        # 类型定义
│   │   ├── application/      # 应用层
│   │   │   ├── use-cases/    # 用例 (业务逻辑入口)
│   │   │   │   ├── create-user.usecase.ts # 创建用户用例
│   │   │   │   ├── activate-user.usecase.ts # 激活用户用例
│   │   │   │   └── update-user-profile.usecase.ts # 更新用户档案用例
│   │   │   ├── commands/     # 命令 (写操作)
│   │   │   │   ├── handlers/ # 命令处理器
│   │   │   │   └── validators/ # 命令验证器
│   │   │   ├── queries/      # 查询 (读操作)
│   │   │   │   ├── handlers/ # 查询处理器
│   │   │   │   └── validators/ # 查询验证器
│   │   │   ├── projections/  # 读模型投影
│   │   │   ├── services/     # 应用服务
│   │   │   └── interfaces/   # 应用层接口
│   │   ├── infrastructure/   # 基础设施层
│   │   │   ├── repositories/ # 仓储实现
│   │   │   ├── mappers/      # 映射器
│   │   │   ├── entities/     # ORM实体
│   │   │   ├── services/     # 基础设施服务
│   │   │   ├── external/     # 外部服务集成
│   │   │   ├── config/       # 配置
│   │   │   └── migrations/   # 数据库迁移
│   │   └── presentation/     # 表现层
│   │       ├── controllers/  # 控制器
│   │       ├── dtos/         # 数据传输对象
│   │       ├── validators/   # 表现层验证器
│   │       ├── guards/       # 权限守卫
│   │       └── interceptors/ # 拦截器
│   ├── package.json
│   └── tsconfig.json

├── organization/              # 组织管理模块
│   ├── src/
│   │   ├── domain/           # 领域层
│   ├── application/          # 应用层
│   ├── infrastructure/       # 基础设施层
│   └── presentation/         # 表现层
│   ├── package.json
│   └── tsconfig.json

├── department/                # 部门管理模块
│   ├── src/
│   │   ├── domain/           # 领域层
│   ├── application/          # 应用层
│   ├── infrastructure/       # 基础设施层
│   └── presentation/         # 表现层
│   ├── package.json
│   └── tsconfig.json

└── iam/                       # 身份认证与授权管理模块
    ├── src/
    │   ├── auth/             # 认证子领域
    │   │   ├── domain/       # 领域层
    │   │   ├── application/  # 应用层
    │   │   ├── infrastructure/ # 基础设施层
    │   │   └── presentation/ # 表现层
    │   ├── role/             # 角色子领域
    │   │   ├── domain/       # 领域层
    │   │   ├── application/  # 应用层
    │   │   ├── infrastructure/ # 基础设施层
    │   │   └── presentation/ # 表现层
    │   ├── permission/       # 权限子领域
    │   │   ├── domain/       # 领域层
    │   │   ├── application/  # 应用层
    │   │   ├── infrastructure/ # 基础设施层
    │   │   └── presentation/ # 表现层
    │   ├── session/          # 会话子领域
    │   │   ├── domain/       # 领域层
    │   │   ├── application/  # 应用层
    │   │   ├── infrastructure/ # 基础设施层
    │   │   └── presentation/ # 表现层
    │   └── audit/            # 审计子领域
    │       ├── domain/       # 领域层
    │       ├── application/  # 应用层
    │       ├── infrastructure/ # 基础设施层
    │       └── presentation/ # 表现层
    ├── package.json
    └── tsconfig.json

libs/shared/                   # 共享基础设施模块
├── src/
│   ├── domain/               # 共享领域组件
│   │   ├── entities/         # 基础实体类
│   │   │   ├── platform-aware.entity.ts # 平台感知实体基类
│   │   │   ├── data-isolation-aware.entity.ts # 数据隔离感知实体基类
│   │   │   └── user-profile.entity.ts # 用户档案实体
│   │   ├── value-objects/    # 通用值对象
│   │   │   ├── uuid.vo.ts    # UUID值对象
│   │   │   ├── email.vo.ts   # 邮箱值对象
│   │   │   └── password.vo.ts # 密码值对象
│   │   └── enums/            # 通用枚举
│   │       ├── data-privacy-level.enum.ts # 数据隐私级别枚举
│   │       └── data-isolation-level.enum.ts # 数据隔离级别枚举
│   ├── infrastructure/       # 共享基础设施
│   └── presentation/         # 共享表现层组件
├── package.json
└── tsconfig.json
```

## 🧪 **测试代码组织架构**

### 测试分层策略

遵循 Clean Architecture 的分层原则和 monorepo 的最佳实践，测试代码应当按照对应的架构层进行组织，确保测试覆盖的完整性和可维护性。

```
测试代码组织架构
├── 单元测试 (Unit Tests) - 与被测试代码同级目录
│   ├── domain/ # 领域层测试
│   │   ├── entities/
│   │   │   ├── user.entity.ts
│   │   │   └── user.entity.spec.ts # 与实体文件同级
│   │   ├── value-objects/
│   │   │   ├── email.value-object.ts
│   │   │   └── email.value-object.spec.ts # 与值对象文件同级
│   │   ├── aggregates/
│   │   │   ├── user.aggregate.ts
│   │   │   └── user.aggregate.spec.ts # 与聚合根文件同级
│   │   ├── domain-services/
│   │   │   ├── user-domain.service.ts
│   │   │   └── user-domain.service.spec.ts # 与领域服务文件同级
│   │   └── domain-events/
│   │       ├── user-created.event.ts
│   │       └── user-created.event.spec.ts # 与事件文件同级
│   ├── application/ # 应用层测试
│   │   ├── use-cases/
│   │   │   ├── create-user.usecase.ts
│   │   │   └── create-user.usecase.spec.ts # 与用例文件同级
│   │   ├── commands/
│   │   │   ├── create-user.command.ts
│   │   │   └── create-user.command.spec.ts # 与命令文件同级
│   │   │   ├── handlers/
│   │   │   │   ├── create-user.handler.ts
│   │   │   │   └── create-user.handler.spec.ts # 与命令处理器文件同级
│   │   │   └── validators/
│   │   │     ├── create-user.validator.ts
│   │   │     └── create-user.validator.spec.ts # 与命令验证器文件同级
│   │   ├── queries/
│   │   │   ├── get-user.query.ts
│   │   │   └── get-user.query.spec.ts # 与查询文件同级
│   │   │   ├── handlers/
│   │   │   │   ├── get-user.handler.ts
│   │   │   │   └── get-user.handler.spec.ts # 与查询处理器文件同级
│   │   │   └── validators/
│   │   │     ├── get-user.validator.ts
│   │   │     └── get-user.validator.spec.ts # 与查询验证器文件同级
│   │   ├── projections/
│   │   │   ├── user-read-model.projection.ts
│   │   │   └── user-read-model.projection.spec.ts # 与投影文件同级
│   │   ├── services/
│   │   │   ├── user.service.ts
│   │   │   └── user.service.spec.ts # 与应用服务文件同级
│   │   └── interfaces/
│   │       ├── user.interface.ts
│   │       └── user.interface.spec.ts # 与接口文件同级
│   ├── infrastructure/ # 基础设施层测试
│   │   ├── repositories/
│   │   │   ├── user.repository.ts
│   │   │   └── user.repository.spec.ts # 与仓储文件同级
│   │   ├── mappers/
│   │   │   ├── user.mapper.ts
│   │   │   └── user.mapper.spec.ts # 与映射器文件同级
│   │   ├── entities/
│   │   │   ├── user.entity.ts
│   │   │   └── user.entity.spec.ts # 与ORM实体文件同级
│   │   ├── services/
│   │   │   ├── email.service.ts
│   │   │   └── email.service.spec.ts # 与基础设施服务文件同级
│   │   ├── external/
│   │   │   ├── payment.service.ts
│   │   │   └── payment.service.spec.ts # 与外部服务文件同级
│   │   ├── config/
│   │   │   ├── database.config.ts
│   │   │   └── database.config.spec.ts # 与配置文件同级
│   │   └── migrations/
│   │       ├── create-users.migration.ts
│   │       └── create-users.migration.spec.ts # 与迁移文件同级
│   └── presentation/ # 表现层测试
│       ├── controllers/
│       │   ├── user.controller.ts
│       │   └── user.controller.spec.ts # 与控制器文件同级
│       ├── dtos/
│       │   ├── create-user.dto.ts
│       │   └── create-user.dto.spec.ts # 与DTO文件同级
│       ├── validators/
│       │   ├── create-user.validator.ts
│       │   └── create-user.validator.spec.ts # 与验证器文件同级
│       ├── guards/
│       │   ├── auth.guard.ts
│       │   └── auth.guard.spec.ts # 与守卫文件同级
│       └── interceptors/
│           ├── logging.interceptor.ts
│           └── logging.interceptor.spec.ts # 与拦截器文件同级
├── 集成测试 (Integration Tests) - 独立目录
│   ├── api/ # API集成测试
│   │   ├── user-api.integration.spec.ts
│   │   └── auth-api.integration.spec.ts
│   ├── database/ # 数据库集成测试
│   │   ├── user-database.integration.spec.ts
│   │   └── transaction.integration.spec.ts
│   ├── external-services/ # 外部服务集成测试
│   │   ├── payment-service.integration.spec.ts
│   │   └── email-service.integration.spec.ts
│   └── event-sourcing/ # 事件溯源集成测试
│       ├── user-events.integration.spec.ts
│       ├── event-store.integration.spec.ts
│       └── projections.integration.spec.ts
├── 端到端测试 (E2E Tests) - 独立目录
│   ├── scenarios/ # 业务场景测试
│   │   ├── user-registration.e2e.spec.ts
│   │   └── user-authentication.e2e.spec.ts
│   ├── workflows/ # 工作流测试
│   │   ├── user-onboarding.e2e.spec.ts
│   │   └── password-reset.e2e.spec.ts
│   └── user-journeys/ # 用户旅程测试
│       ├── complete-user-flow.e2e.spec.ts
│       └── admin-dashboard.e2e.spec.ts
└── 性能测试 (Performance Tests) - 独立目录
    ├── load/ # 负载测试
    │   ├── user-api.load.spec.ts
    │   └── database.load.spec.ts
    ├── stress/ # 压力测试
    │   ├── user-api.stress.spec.ts
    │   └── concurrent-users.stress.spec.ts
    └── benchmark/ # 基准测试
        ├── query-performance.benchmark.spec.ts
        └── memory-usage.benchmark.spec.ts
```

### 测试文件命名规范

测试文件命名应当与被测试文件保持一致，并添加相应的后缀。

```
测试文件命名规范
├── 单元测试: *.spec.ts (与被测试文件同级目录)
│   ├── user.entity.ts → user.entity.spec.ts # 实体测试
│   ├── create-user.usecase.ts → create-user.usecase.spec.ts # 用例测试
│   ├── user.repository.ts → user.repository.spec.ts # 仓储测试
│   ├── user.service.ts → user.service.spec.ts # 服务测试
│   ├── user.controller.ts → user.controller.spec.ts # 控制器测试
│   ├── auth.guard.ts → auth.guard.spec.ts # 守卫测试
│   └── logging.interceptor.ts → logging.interceptor.spec.ts # 拦截器测试
├── 集成测试: *.integration.spec.ts (独立目录)
│   ├── user-api.integration.spec.ts # API集成测试
│   ├── user-database.integration.spec.ts # 数据库集成测试
│   ├── user-events.integration.spec.ts # 事件溯源集成测试
│   ├── projections.integration.spec.ts # 投影集成测试
│   └── payment-service.integration.spec.ts # 外部服务集成测试
├── 端到端测试: *.e2e.spec.ts (独立目录)
│   ├── user-registration.e2e.spec.ts # 用户注册E2E测试
│   ├── user-authentication.e2e.spec.ts # 用户认证E2E测试
│   ├── user-workflow.e2e.spec.ts # 用户工作流E2E测试
│   └── admin-dashboard.e2e.spec.ts # 管理面板E2E测试
└── 性能测试: *.performance.spec.ts (独立目录)
    ├── user-api.performance.spec.ts # API性能测试
    ├── database-query.performance.spec.ts # 数据库查询性能测试
    ├── memory-usage.performance.spec.ts # 内存使用性能测试
    └── concurrent-users.performance.spec.ts # 并发用户性能测试
```

### 测试数据管理

```
测试数据管理策略
├── fixtures/ # 测试数据文件
│   ├── users/ # 用户测试数据
│   │   ├── valid-users.json # 有效用户数据
│   │   ├── invalid-users.json # 无效用户数据
│   │   └── edge-cases.json # 边界情况数据
│   ├── organizations/ # 组织测试数据
│   └── permissions/ # 权限测试数据
├── factories/ # 测试数据工厂
│   ├── user.factory.ts # 用户工厂
│   ├── organization.factory.ts # 组织工厂
│   └── permission.factory.ts # 权限工厂
├── mocks/ # 模拟对象
│   ├── repositories/ # 仓储模拟
│   ├── services/ # 服务模拟
│   └── external/ # 外部服务模拟
└── helpers/ # 测试辅助工具
    ├── test-database.helper.ts # 测试数据库助手
    ├── test-events.helper.ts # 测试事件助手
    └── test-auth.helper.ts # 测试认证助手
```

### 测试配置管理

```
测试配置管理
├── jest.config.ts # Jest主配置
├── jest-unit.config.ts # 单元测试配置
├── jest-integration.config.ts # 集成测试配置
├── jest-e2e.config.ts # E2E测试配置
├── jest-performance.config.ts # 性能测试配置
├── test-environment/ # 测试环境配置
│   ├── test-database.config.ts # 测试数据库配置
│   ├── test-redis.config.ts # 测试Redis配置
│   └── test-postgresql.config.ts # 测试PostgreSQL配置
└── coverage/ # 测试覆盖率配置
    ├── coverage.config.ts # 覆盖率配置
    └── thresholds/ # 覆盖率阈值
        ├── unit.threshold.ts # 单元测试阈值
        ├── integration.threshold.ts # 集成测试阈值
        └── e2e.threshold.ts # E2E测试阈值
```

### 测试执行策略

```
测试执行策略
├── 开发阶段测试
│   ├── 单元测试: pnpm test --watch # 监听模式
│   ├── 快速集成测试: pnpm test --testPathPattern=integration
│   └── 代码覆盖率: pnpm test --coverage
├── 提交前测试
│   ├── 全量单元测试: pnpm test
│   ├── 关键集成测试: pnpm test --testPathPattern=critical
│   └── 代码质量检查: pnpm lint && pnpm test --coverage
├── 持续集成测试
│   ├── 全量测试套件: pnpm run-many --target=test --all
│   ├── 并行测试执行: pnpm run-many --target=test --parallel=4
│   └── 测试报告生成: pnpm test --coverage --reporter=html
└── 生产前测试
    ├── 端到端测试: pnpm e2e
    ├── 性能测试: pnpm performance
    └── 安全测试: pnpm security-test
```

### 测试最佳实践

```
测试最佳实践
├── 测试原则
│   ├── 单一职责: 每个测试只验证一个功能点
│   ├── 独立性: 测试之间不应相互依赖
│   ├── 可重复性: 测试结果应保持一致
│   └── 快速执行: 单元测试应在毫秒级完成
├── 测试模式
│   ├── AAA模式: Arrange-Act-Assert
│   ├── Given-When-Then: 行为驱动开发
│   ├── 测试替身: Mock、Stub、Spy、Fake
│   └── 测试数据构建器: Builder Pattern
├── 测试覆盖策略
│   ├── 代码覆盖率: 单元测试 > 80%
│   ├── 分支覆盖率: 关键分支 > 90%
│   ├── 路径覆盖率: 复杂逻辑 > 95%
│   └── 集成覆盖率: 关键流程 > 70%
└── 测试维护
    ├── 测试重构: 保持测试代码整洁
    ├── 测试文档: 清晰的测试描述
    ├── 测试审查: 代码审查包含测试
    └── 测试监控: 持续监控测试质量
```

```

```
