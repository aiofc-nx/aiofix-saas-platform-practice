---
description: 代码注释规则
globs:
alwaysApply: true
---

# SAAS平台代码注释规范（Code Annotation Specification）

**遵循代码即文档的思想，应当保证代码与注释的一致性和规范性。**

## **项目概述**

本项目是一个企业级SAAS平台，采用以下技术架构：
- **架构模式**: Clean Architecture + DDD + CQRS + Event Sourcing
- **技术栈**: TypeScript + NestJS + PostgreSQL + MongoDB + Redis
- **API设计**: RESTful API + GraphQL
- **数据隔离**: 多层级数据隔离策略（平台、租户、组织、部门、用户级）
- **认证授权**: IAM模块，支持RBAC、ABAC、PBAC

## **代码注释规则**

- 本项目代码应当按照 TSDoc 规范添加注释。主要代码应当写入代码的原理与机制，功能与职责。修改代码时应当同时修改相应的注释，确保代码与注释一致。
- 所有公共 API、类、方法、接口、枚举等都必须添加完整的 TSDoc 注释。
- 注释应当清晰、准确、完整，避免冗余和过时的信息。
- 使用中文进行注释，确保团队理解的一致性。
- **SAAS平台特殊要求**: 所有涉及数据隔离、权限控制、多租户的代码必须详细说明其隔离策略和访问控制机制。

## **TSDoc 注释结构**

### 基本结构

```typescript
/**
 * @description 功能描述
 * @param {Type} paramName 参数描述
 * @returns {Type} 返回值描述
 * @throws {ErrorType} 异常描述
 * @example 使用示例
 */
```

### 详细结构

````typescript
/**
 * @function functionName
 * @description
 * 详细的功能描述，包含：
 * 1. 主要功能说明
 * 2. 使用场景
 * 3. 注意事项
 *
 * 原理与机制：
 * 1. 实现原理说明
 * 2. 技术选型理由
 * 3. 性能考虑
 *
 * 功能与职责：
 * 1. 核心职责
 * 2. 边界条件
 * 3. 依赖关系
 *
 * @param {Type} paramName 参数详细描述
 * @param {Type} [optionalParam] 可选参数描述
 * @returns {Type} 返回值详细描述
 * @throws {ErrorType} 可能抛出的异常及条件
 * @example
 * ```typescript
 * const result = functionName(param1, param2);
 * console.log(result);
 * ```
 * @since 1.0.0
 * @deprecated 如果已废弃，说明替代方案
 */
````

````ts
import { NestFactory } from '@nestjs/core';
import {
  FastifyAdapter,
  NestFastifyApplication,
} from '@nestjs/platform-fastify';
import { AppModule } from './app.module';

/**
 * @function bootstrap
 * @description
 * 启动NestJS应用的主函数。该函数负责创建基于Fastify平台的应用实例，
 * 并监听指定端口启动高性能HTTP服务。
 *
 * 原理与机制：
 * 1. 通过NestFactory.create创建应用实例，使用FastifyAdapter作为HTTP适配器，
 *    Fastify是一个高性能的Node.js web框架，相比Express具有更好的性能表现。
 * 2. FastifyAdapter提供了Fastify与NestJS的集成，使得NestJS可以充分利用Fastify的高性能特性，如更快的路由匹配、更低的延迟等。
 * 3. 最后通过listen方法监听环境变量PORT指定的端口（默认3000），启动HTTP服务。
 *
 * 功能与职责：
 * 1. 启动应用服务器
 * 2. 配置全局中间件和管道
 * 3. 初始化数据库连接
 * 4. 启动事件监听器
 *
 * @returns {Promise<void>} 返回一个Promise，表示应用启动过程
 * @throws {Error} 当端口被占用或配置错误时抛出异常
 * @example
 * ```typescript
 * // 启动应用
 * bootstrap().catch(error => {
 *   console.error('Failed to start application:', error);
 *   process.exit(1);
 * });
 * ```
 * @since 1.0.0
 */
async function bootstrap() {
  // 创建基于Fastify的Nest应用实例
  const app = await NestFactory.create<NestFastifyApplication>(
    AppModule,
    new FastifyAdapter()
  );

  // 启动HTTP服务，监听指定端口
  await app.listen(process.env.PORT ?? 3000, '0.0.0.0');
}

// 启动应用
bootstrap();
````

## **分层架构注释规范**

本项目按照整洁架构（Clean Architecture）原则组织代码，每个功能组件都应当按照其所在层（Layer）和组件实际承担的职责增加相应的注释。

### **SAAS平台架构特点**

- **多租户架构**: 支持平台、租户、组织、部门、用户多层级数据隔离
- **数据隔离感知**: 所有业务实体都继承自数据隔离感知基类
- **权限控制**: 基于RBAC、ABAC、PBAC的细粒度权限控制
- **事件溯源**: 完整的状态变更历史追踪和审计
- **CQRS模式**: 命令查询职责分离，读写模型独立
- **GraphQL支持**: 灵活的查询接口，支持复杂数据关联

### 领域层（Domain Layer）注释规范

领域层组件应当重点说明业务规则、领域概念和实体关系。例如，领域层的实体组件应参考如下注释示例：

#### **数据隔离感知实体注释规范**

SAAS平台的所有业务实体都继承自数据隔离感知基类，必须详细说明其数据隔离策略和访问控制机制。

````
/**
 * @class User
 * @description
 * 用户领域实体，代表系统中的用户对象，包含用户的核心属性和行为。
 *
 * 原理与机制：
 * 1. 作为领域层的实体，User聚合了与用户相关的属性（如id、name、email等）和业务方法（如修改邮箱、激活账户等）。
 * 2. 实体的唯一性由id属性保证，所有与用户相关的业务规则应在该实体内实现，确保领域一致性。
 * 3. 领域实体不依赖于基础设施和外部服务，仅关注业务规则和状态变更。
 * 4. 使用值对象封装复杂属性，确保领域概念的完整性。
 *
 * 功能与职责：
 * 1. 表达用户的核心业务属性和行为
 * 2. 封装与用户相关的业务规则
 * 3. 保证用户实体的一致性和完整性
 * 4. 提供领域事件发布能力
 *
 * @example
 * ```typescript
 * const user = new User('user-123', 'John Doe', 'john@example.com');
 * user.changeEmail('newemail@example.com');
 * user.activate();
 * ```
 * @since 1.0.0
 */
export class User {
  /**
   * 用户唯一标识
   * @description 全局唯一的用户标识符，用于区分不同的用户实体
   */
  private readonly id: string;

  /**
   * 用户名
   * @description 用户的显示名称，用于界面展示和用户识别
   */
  private name: string;

  /**
   * 用户邮箱
   * @description 用户的电子邮箱地址，用于登录和通知
   */
  private email: string;

  /**
   * 构造函数，初始化用户实体
   * @description 创建用户实体实例，设置基本属性并验证数据有效性
   * @param {string} id 用户唯一标识，必须为非空字符串
   * @param {string} name 用户名，长度在2-50个字符之间
   * @param {string} email 用户邮箱，必须符合邮箱格式规范
   * @throws {InvalidArgumentException} 当参数无效时抛出异常
   */
  constructor(id: string, name: string, email: string) {
    this.id = id;
    this.name = name;
    this.email = email;
  }

  /**
   * 修改用户邮箱
   * @description 更新用户的邮箱地址，包含邮箱格式验证和重复性检查
   * @param {string} newEmail 新的邮箱地址，必须符合邮箱格式规范
   * @throws {InvalidEmailException} 当邮箱格式无效时抛出异常
   * @throws {EmailAlreadyExistsException} 当邮箱已被其他用户使用时抛出异常
   * @example
   * ```typescript
   * user.changeEmail('newemail@example.com');
   * ```
   */
  public changeEmail(newEmail: string): void {
    // 业务规则：邮箱格式校验等
    this.email = newEmail;
  }

  /**
   * 获取用户ID
   * @description 获取用户的唯一标识符
   * @returns {string} 用户唯一标识符
   */
  public getId(): string {
    return this.id;
  }

  /**
   * 获取用户名
   * @description 获取用户的显示名称
   * @returns {string} 用户名
   */
  public getName(): string {
    return this.name;
  }

  /**
   * 获取用户邮箱
   * @description 获取用户的电子邮箱地址
   * @returns {string} 用户邮箱地址
   */
  public getEmail(): string {
    return this.email;
  }
}
```

#### **数据隔离感知实体注释示例**

```typescript
/**
 * @class TenantUser
 * @description
 * 租户用户实体，代表在特定租户下的用户实例，支持跨层级数据隔离。
 *
 * 原理与机制：
 * 1. 继承自DataIsolationAwareEntity，支持多层级数据隔离（平台、租户、组织、部门、用户级）
 * 2. 支持跨层级存在：用户级数据可以存在于任何组织层级下，但访问控制基于用户身份
 * 3. 数据隐私级别：支持SHARED（可共享）和PROTECTED（受保护）两种级别
 * 4. 访问控制：基于隔离级别和隐私级别的细粒度访问控制
 *
 * 数据隔离策略：
 * 1. 隔离级别：DataIsolationLevel.USER（用户级）
 * 2. 隐私级别：DataPrivacyLevel.PROTECTED（受保护）
 * 3. 跨层级支持：可以属于租户、组织、部门等不同层级
 * 4. 访问规则：同租户内可访问，跨租户禁止访问
 *
 * 功能与职责：
 * 1. 表达租户用户的核心业务属性和行为
 * 2. 封装与租户用户相关的业务规则
 * 3. 保证租户用户实体的一致性和完整性
 * 4. 提供数据隔离感知的访问控制能力
 *
 * @example
 * ```typescript
 * // 创建租户级用户（无组织归属）
 * const tenantUser = TenantUser.createTenantUser(
 *   new Uuid('tenant-123'),
 *   'john.doe',
 *   'john@example.com'
 * );
 * 
 * // 创建组织级用户
 * const orgUser = TenantUser.createOrganizationUser(
 *   new Uuid('tenant-123'),
 *   'jane.smith',
 *   'jane@example.com',
 *   new Uuid('org-456')
 * );
 * 
 * // 创建部门级用户
 * const deptUser = TenantUser.createDepartmentUser(
 *   new Uuid('tenant-123'),
 *   'bob.wilson',
 *   'bob@example.com',
 *   new Uuid('org-456'),
 *   [new Uuid('dept-789')]
 * );
 * ```
 * @since 1.0.0
 */
export class TenantUser extends DataIsolationAwareEntity {
  private _username: string;
  private _email: string;
  private _status: UserStatus;

  constructor(
    tenantId: Uuid,
    username: string,
    email: string,
    organizationId?: Uuid,
    departmentIds: Uuid[] = [],
    dataPrivacyLevel: DataPrivacyLevel = DataPrivacyLevel.PROTECTED,
    id?: Uuid
  ) {
    super(
      tenantId,
      DataIsolationLevel.USER,
      dataPrivacyLevel,
      id,
      organizationId,
      departmentIds,
      id // userId 与实体ID相同
    );
    this._username = username;
    this._email = email;
    this._status = UserStatus.ACTIVE;
  }

  /**
   * 检查是否可以访问目标实体
   * @description 基于数据隔离策略检查访问权限
   * @param {DataIsolationAwareEntity} target 目标实体
   * @returns {boolean} 是否允许访问
   * 
   * 访问控制逻辑：
   * 1. 首先检查租户是否匹配
   * 2. 然后检查隔离级别和隐私级别
   * 3. 最后检查具体的业务权限
   */
  public canAccess(target: DataIsolationAwareEntity): boolean {
    return super.canAccess(target);
  }

  /**
   * 断言同租户访问权限
   * @description 确保操作的目标实体属于同一租户
   * @param {DataIsolationAwareEntity} other 目标实体
   * @throws {TenantAccessDeniedError} 当跨租户访问时抛出异常
   */
  protected assertSameTenant(other: DataIsolationAwareEntity): void {
    super.assertSameTenant(other);
  }
}
```

### 应用层（Application Layer）注释规范

应用层组件应当重点说明用例、业务流程和协调逻辑。

```typescript
/**
 * @class CreateUserUseCase
 * @description
 * 创建用户的用例，负责协调用户创建的业务流程。
 *
 * 原理与机制：
 * 1. 作为应用层的用例，CreateUserUseCase协调领域服务和基础设施服务。
 * 2. 使用命令模式封装用户创建请求，确保请求的不可变性。
 * 3. 通过领域事件实现松耦合的业务流程。
 * 4. 使用事务确保数据一致性。
 *
 * 功能与职责：
 * 1. 验证用户创建请求的有效性
 * 2. 协调用户实体创建和持久化
 * 3. 发送用户创建成功事件
 * 4. 处理用户创建失败的回滚
 *
 * @example
 * ```typescript
 * const useCase = new CreateUserUseCase(userRepo, eventBus);
 * const result = await useCase.execute({
 *   name: 'John Doe',
 *   email: 'john@example.com'
 * });
 * ```
 * @since 1.0.0
 */
export class CreateUserUseCase {
  /**
   * 执行用户创建用例
   * @description 创建新用户并处理相关的业务流程
   * @param {CreateUserCommand} command 用户创建命令
   * @returns {Promise<User>} 创建成功的用户实体
   * @throws {ValidationException} 当命令参数无效时抛出异常
   * @throws {UserAlreadyExistsException} 当用户已存在时抛出异常
   */
  async execute(command: CreateUserCommand): Promise<User> {
    // 实现逻辑
  }
}
```

#### **CQRS模式注释规范**

SAAS平台采用CQRS模式，命令端负责写操作，查询端负责读操作，必须明确区分两者的职责和实现方式。

### 基础设施层（Infrastructure Layer）注释规范

基础设施层组件应当重点说明技术实现、外部服务集成和配置管理。

```typescript
/**
 * @class PostgresUserRepository
 * @description
 * PostgreSQL用户仓储实现，负责用户数据的持久化操作。
 *
 * 原理与机制：
 * 1. 实现UserRepository接口，提供用户数据的CRUD操作。
 * 2. 使用MikroORM进行对象关系映射，简化数据库操作。
 * 3. 实现连接池管理，提高数据库访问性能。
 * 4. 使用事务确保数据一致性。
 *
 * 功能与职责：
 * 1. 用户数据的增删改查操作
 * 2. 数据库连接管理和事务处理
 * 3. 查询优化和性能监控
 * 4. 数据迁移和版本管理
 *
 * @example
 * ```typescript
 * const repository = new PostgresUserRepository(em);
 * const user = await repository.findById('user-123');
 * ```
 * @since 1.0.0
 */
export class PostgresUserRepository implements UserRepository {
  /**
   * 根据ID查找用户
   * @description 通过用户ID从数据库中查找用户实体
   * @param {string} id 用户唯一标识
   * @returns {Promise<User | null>} 用户实体或null
   * @throws {DatabaseConnectionException} 当数据库连接失败时抛出异常
   */
  async findById(id: string): Promise<User | null> {
    // 实现逻辑
  }
}
```

#### **CQRS命令和查询注释示例**

```typescript
/**
 * @class CreateUserCommand
 * @description
 * 创建用户命令，封装用户创建的写操作请求。
 *
 * 原理与机制：
 * 1. 作为CQRS命令端的命令对象，封装用户创建的所有必要信息
 * 2. 命令是不可变的，一旦创建就不能修改，确保请求的不可变性
 * 3. 通过命令总线传递给对应的命令处理器执行
 * 4. 支持事件溯源，记录所有状态变更
 *
 * 数据隔离考虑：
 * 1. 命令包含租户ID，确保数据隔离
 * 2. 命令包含当前用户ID，用于权限验证和审计
 * 3. 支持跨层级用户创建（租户级、组织级、部门级）
 *
 * @example
 * ```typescript
 * const command = new CreateUserCommand(
 *   'john.doe',
 *   'john@example.com',
 *   'password123',
 *   'tenant-123',
 *   'current-user-456'
 * );
 * await commandBus.execute(command);
 * ```
 * @since 1.0.0
 */
export class CreateUserCommand {
  constructor(
    public readonly username: string,
    public readonly email: string,
    public readonly password: string,
    public readonly tenantId: string,
    public readonly currentUserId: string
  ) {}
}

/**
 * @class GetUserByIdQuery
 * @description
 * 根据ID查询用户查询对象，封装用户查询的读操作请求。
 *
 * 原理与机制：
 * 1. 作为CQRS查询端的查询对象，封装用户查询的所有必要信息
 * 2. 查询通过查询总线传递给对应的查询处理器执行
 * 3. 查询结果来自读模型，不直接操作领域实体
 * 4. 支持数据隔离和权限验证
 *
 * 数据隔离考虑：
 * 1. 查询包含租户ID，确保数据隔离
 * 2. 查询包含当前用户ID，用于权限验证
 * 3. 支持跨层级用户查询（基于用户权限）
 *
 * @example
 * ```typescript
 * const query = new GetUserByIdQuery(
 *   'user-123',
 *   'current-user-456'
 * );
 * const user = await queryBus.execute(query);
 * ```
 * @since 1.0.0
 */
export class GetUserByIdQuery {
  constructor(
    public readonly userId: string,
    public readonly currentUserId: string
  ) {}
}

/**
 * @class CreateUserHandler
 * @description
 * 创建用户命令处理器，负责执行用户创建的业务逻辑。
 *
 * 原理与机制：
 * 1. 实现CommandHandler接口，处理CreateUserCommand命令
 * 2. 通过聚合根管理业务规则和一致性
 * 3. 使用事件存储保存领域事件
 * 4. 支持事务和回滚机制
 *
 * 数据隔离实现：
 * 1. 验证租户访问权限
 * 2. 创建数据隔离感知的用户实体
 * 3. 记录数据隔离相关的审计日志
 *
 * @example
 * ```typescript
 * @CommandHandler(CreateUserCommand)
 * export class CreateUserHandler {
 *   async execute(command: CreateUserCommand): Promise<void> {
 *     // 1. 权限验证
 *     await this.permissionService.checkPermission(
 *       command.currentUserId,
 *       'user',
 *       'create',
 *       command.tenantId
 *     );
 * 
 *     // 2. 创建用户聚合根
 *     const userAggregate = UserAggregate.create(
 *       command.username,
 *       command.email,
 *       command.password,
 *       command.tenantId
 *     );
 * 
 *     // 3. 保存聚合根和事件
 *     await this.userRepository.save(userAggregate);
 *     await this.eventStore.saveEvents(
 *       userAggregate.getId(),
 *       userAggregate.getUncommittedEvents(),
 *       userAggregate.getVersion()
 *     );
 *   }
 * }
 * ```
 * @since 1.0.0
 */
```

### 表现层（Presentation Layer）注释规范

表现层组件应当重点说明API接口、请求处理和响应格式。

#### **GraphQL注释规范**

SAAS平台同时支持RESTful API和GraphQL，GraphQL组件必须详细说明其查询优化和权限控制机制。

```typescript
/**
 * @class UserController
 * @description
 * 用户控制器，处理用户相关的HTTP请求和响应。
 *
 * 原理与机制：
 * 1. 使用NestJS装饰器定义路由和请求方法。
 * 2. 通过DTO验证和转换请求数据。
 * 3. 使用拦截器处理通用逻辑如日志、缓存等。
 * 4. 通过管道进行数据验证和转换。
 *
 * 功能与职责：
 * 1. 接收和验证HTTP请求
 * 2. 调用应用层用例处理业务逻辑
 * 3. 格式化HTTP响应
 * 4. 处理异常和错误响应
 *
 * @example
 * ```typescript
 * // POST /users
 * const user = await userController.create(createUserDto);
 * ```
 * @since 1.0.0
 */
@Controller('users')
export class UserController {
  /**
   * 创建用户
   * @description 创建新用户的API接口
   * @param {CreateUserDto} createUserDto 用户创建数据传输对象
   * @returns {Promise<UserResponseDto>} 创建成功的用户信息
   * @throws {BadRequestException} 当请求参数无效时抛出异常
   * @throws {ConflictException} 当用户已存在时抛出异常
   */
  @Post()
  @UseGuards(AuthGuard)
  async create(@Body() createUserDto: CreateUserDto): Promise<UserResponseDto> {
    // 实现逻辑
  }
}
```

## **注释质量检查清单**

### 必需检查项
- [ ] 所有公共API都有完整的TSDoc注释
- [ ] 注释包含@description、@param、@returns等必要标签
- [ ] 注释内容准确反映代码的实际功能
- [ ] 注释使用中文，确保团队理解一致性
- [ ] 注释包含原理与机制说明
- [ ] 注释包含功能与职责说明
- [ ] **SAAS平台特殊要求**: 所有涉及数据隔离的代码必须说明隔离策略和访问控制机制
- [ ] **SAAS平台特殊要求**: 所有涉及权限控制的代码必须说明权限验证流程和缓存策略
- [ ] **SAAS平台特殊要求**: 所有涉及多租户的代码必须说明租户隔离策略

### 推荐检查项
- [ ] 注释包含@example使用示例
- [ ] 注释包含@throws异常说明
- [ ] 注释包含@since版本信息
- [ ] 注释包含@deprecated废弃说明（如适用）
- [ ] 注释包含性能考虑和限制说明
- [ ] 注释包含依赖关系和约束条件
- [ ] **SAAS平台推荐**: 注释包含数据隔离级别和隐私级别说明
- [ ] **SAAS平台推荐**: 注释包含权限模型（RBAC/ABAC/PBAC）说明
- [ ] **SAAS平台推荐**: 注释包含事件溯源和审计追踪说明
- [ ] **SAAS平台推荐**: 注释包含GraphQL查询优化策略说明

### 注释维护原则
1. **及时更新**: 代码修改时必须同步更新注释
2. **保持简洁**: 注释应当简洁明了，避免冗余
3. **突出重点**: 重点说明复杂逻辑和业务规则
4. **保持一致性**: 使用统一的注释风格和术语
5. **定期审查**: 定期审查注释的准确性和完整性

## **SAAS平台特殊注释规范**

### **事件溯源注释规范**

```typescript
/**
 * @class UserCreatedEvent
 * @description
 * 用户创建领域事件，记录用户创建的状态变更。
 *
 * 原理与机制：
 * 1. 继承自DomainEvent，支持事件溯源和状态重建
 * 2. 包含完整的事件元数据（租户ID、用户ID、时间戳等）
 * 3. 通过事件存储持久化，支持事件重放和审计
 * 4. 触发读模型投影，更新查询端数据
 *
 * 数据隔离信息：
 * 1. 事件包含租户ID，确保事件隔离
 * 2. 事件包含用户ID，用于审计追踪
 * 3. 事件包含数据隔离级别和隐私级别
 *
 * @example
 * ```typescript
 * const event = new UserCreatedEvent(
 *   'user-123',
 *   'john.doe',
 *   'john@example.com',
 *   'tenant-456',
 *   DataIsolationLevel.USER,
 *   DataPrivacyLevel.PROTECTED
 * );
 * ```
 * @since 1.0.0
 */
export class UserCreatedEvent extends DomainEvent {
  constructor(
    public readonly userId: string,
    public readonly username: string,
    public readonly email: string,
    public readonly tenantId: string,
    public readonly isolationLevel: DataIsolationLevel,
    public readonly privacyLevel: DataPrivacyLevel
  ) {
    super('UserCreated', {
      userId,
      username,
      email,
      tenantId,
      isolationLevel,
      privacyLevel
    });
  }
}
```

### **聚合根注释规范**

```typescript
/**
 * @class UserAggregate
 * @description
 * 用户聚合根，管理用户实体的业务规则和一致性边界。
 *
 * 原理与机制：
 * 1. 继承自AggregateRoot，支持事件溯源和状态管理
 * 2. 封装用户相关的业务规则和一致性约束
 * 3. 管理用户实体的生命周期和状态变更
 * 4. 产生领域事件，支持事件驱动架构
 *
 * 数据隔离管理：
 * 1. 聚合根包含数据隔离信息，确保一致性
 * 2. 支持跨层级用户管理（租户级、组织级、部门级）
 * 3. 业务规则验证包含数据隔离检查
 *
 * @example
 * ```typescript
 * const userAggregate = UserAggregate.create(
 *   'john.doe',
 *   'john@example.com',
 *   'password123',
 *   'tenant-456'
 * );
 * 
 * userAggregate.changeEmail('newemail@example.com');
 * userAggregate.joinOrganization('org-789');
 * 
 * const events = userAggregate.getUncommittedEvents();
 * await eventStore.saveEvents(userAggregate.getId(), events);
 * ```
 * @since 1.0.0
 */
export class UserAggregate extends AggregateRoot {
  private user: UserEntity;
  private uncommittedEvents: DomainEvent[] = [];

  static create(
    username: string,
    email: string,
    password: string,
    tenantId: string
  ): UserAggregate {
    const aggregate = new UserAggregate();
    const userId = UserId.generate();

    // 创建用户实体（数据隔离感知）
    aggregate.user = UserEntity.create(
      userId,
      username,
      email,
      tenantId
    );

    // 应用业务规则
    aggregate.validatePassword(password);

    // 产生领域事件
    aggregate.apply(
      new UserCreatedEvent(
        userId,
        username,
        email,
        tenantId,
        DataIsolationLevel.USER,
        DataPrivacyLevel.PROTECTED
      )
    );

    return aggregate;
  }

  changeEmail(newEmail: string): void {
    // 业务规则验证
    if (this.user.email.equals(newEmail)) {
      return;
    }

    // 更新实体
    this.user.changeEmail(newEmail);

    // 产生领域事件
    this.apply(
      new UserEmailChangedEvent(
        this.user.id,
        this.user.email,
        newEmail
      )
    );
  }

  private validatePassword(password: string): void {
    // 密码策略业务规则
    if (password.length < 8) {
      throw new InvalidPasswordException('Password must be at least 8 characters');
    }
  }
}
```

### **权限控制注释规范**

```typescript
/**
 * @class PermissionService
 * @description
 * 权限服务，提供细粒度的权限控制和验证。
 *
 * 原理与机制：
 * 1. 支持RBAC（基于角色）、ABAC（基于属性）、PBAC（基于策略）三种权限模型
 * 2. 集成数据隔离策略，确保权限验证的完整性
 * 3. 支持动态权限控制，根据上下文动态调整权限
 * 4. 提供权限缓存，提高验证性能
 *
 * 权限验证流程：
 * 1. 用户身份验证
 * 2. 角色权限检查
 * 3. 数据隔离验证
 * 4. 业务规则验证
 * 5. 审计日志记录
 *
 * @example
 * ```typescript
 * // 检查用户是否有权限查看特定用户
 * const hasPermission = await permissionService.checkPermission(
 *   currentUserId,
 *   'user',
 *   'read',
 *   targetUserId,
 *   {
 *     tenantId: 'tenant-123',
 *     isolationLevel: DataIsolationLevel.USER,
 *     privacyLevel: DataPrivacyLevel.PROTECTED
 *   }
 * );
 * ```
 * @since 1.0.0
 */
export class PermissionService {
  constructor(
    private readonly userRepository: UserRepository,
    private readonly permissionRepository: PermissionRepository,
    private readonly dataAccessControlService: DataAccessControlService,
    private readonly cacheService: CacheService
  ) {}

  /**
   * 检查用户权限
   * @description 综合验证用户的权限和访问控制
   * @param {string} userId 用户ID
   * @param {string} resource 资源类型
   * @param {string} action 操作类型
   * @param {string} targetId 目标资源ID
   * @param {PermissionContext} context 权限上下文
   * @returns {Promise<boolean>} 是否有权限
   * 
   * 验证步骤：
   * 1. 从缓存获取用户权限
   * 2. 检查角色权限
   * 3. 验证数据隔离
   * 4. 检查业务规则
   */
  async checkPermission(
    userId: string,
    resource: string,
    action: string,
    targetId: string,
    context: PermissionContext
  ): Promise<boolean> {
    // 1. 权限缓存检查
    const cacheKey = `permission:${userId}:${resource}:${action}`;
    const cachedPermission = await this.cacheService.get(cacheKey);
    if (cachedPermission !== null) {
      return cachedPermission;
    }

    // 2. 角色权限检查
    const hasRolePermission = await this.checkRolePermission(
      userId,
      resource,
      action
    );

    if (!hasRolePermission) {
      await this.cacheService.set(cacheKey, false, 300); // 缓存5分钟
      return false;
    }

    // 3. 数据隔离验证
    const hasDataAccess = await this.dataAccessControlService.checkAccess(
      userId,
      targetId,
      context
    );

    const finalPermission = hasRolePermission && hasDataAccess;
    await this.cacheService.set(cacheKey, finalPermission, 300);

    return finalPermission;
  }
}
```

## **总结**

本SAAS平台代码注释规范为企业级多租户SAAS平台提供了完整的注释指导，涵盖：

### **核心特性**
- **多层级数据隔离**: 平台、租户、组织、部门、用户级隔离策略
- **细粒度权限控制**: RBAC、ABAC、PBAC三种权限模型
- **事件溯源架构**: 完整的状态变更历史和审计追踪
- **CQRS模式**: 命令查询职责分离，读写模型独立
- **GraphQL支持**: 灵活查询接口，支持复杂数据关联

### **注释要求**
- 所有涉及数据隔离的代码必须详细说明隔离策略和访问控制机制
- 所有涉及权限控制的代码必须说明权限验证流程和缓存策略
- 所有涉及多租户的代码必须说明租户隔离策略
- 所有事件溯源相关代码必须说明事件存储和状态重建机制
- 所有GraphQL相关代码必须说明查询优化和批量加载策略

### **开发指导**
通过遵循本规范，开发团队能够：
1. 确保代码文档的一致性和完整性
2. 提高代码的可维护性和可理解性
3. 促进团队协作和知识共享
4. 保证SAAS平台的安全性和性能

---

**文档版本**: v2.0.0  
**适用范围**: SAAS平台所有TypeScript代码  
**更新日期**: 2024-12-19
